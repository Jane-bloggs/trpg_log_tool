<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>TRPG Log Comic Viewer Builder</title>
  <style>
    :root {
      --bg-a: #f7f1dc;
      --bg-b: #f9d8b6;
      --panel: #fffaf0;
      --ink: #2f2a22;
      --accent: #d67d53;
      --line: #cdb79f;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Hiragino Kaku Gothic ProN", "Yu Gothic UI", "Meiryo", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 15% 20%, #ffe8c8 0 18%, transparent 19%),
        radial-gradient(circle at 85% 75%, #ffd8be 0 14%, transparent 15%),
        linear-gradient(145deg, var(--bg-a), var(--bg-b));
      min-height: 100vh;
    }
    .layout {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 16px;
      padding: 16px;
      max-width: 1400px;
      margin: 0 auto;
    }
    .panel {
      background: color-mix(in srgb, var(--panel) 95%, #fff);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 10px 20px rgba(0,0,0,.06);
    }
    h1 {
      margin: 0 0 10px;
      font-size: 18px;
      letter-spacing: .03em;
    }
    h2 {
      margin: 12px 0 8px;
      font-size: 14px;
    }
    .hint {
      font-size: 12px;
      color: #645848;
      margin: 4px 0;
    }
    .toolbar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    button, .file-label {
      border: 1px solid #b79f85;
      background: #fff;
      color: var(--ink);
      border-radius: 10px;
      padding: 7px 10px;
      font-size: 13px;
      cursor: pointer;
    }
    .file-label {
      display: inline-block;
      margin-bottom: 6px;
    }
    #fileName {
      margin-top: 4px;
      word-break: break-all;
    }
    button.primary {
      background: var(--accent);
      color: #fff;
      border-color: #ba6843;
    }
    button:disabled {
      opacity: .5;
      cursor: default;
    }
    .scroll {
      max-height: 180px;
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px;
      background: #fffcf7;
    }
    .attr-item {
      display: flex;
      gap: 6px;
      align-items: center;
      margin: 4px 0;
      font-size: 13px;
    }
    .char-list {
      max-height: 260px;
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px;
      background: #fffcf7;
    }
    .char-row {
      display: grid;
      grid-template-columns: auto 1fr auto auto auto;
      align-items: center;
      gap: 8px;
      padding: 5px 0;
      border-bottom: 1px dashed #d9c8b5;
    }
    .char-toggle {
      width: 16px;
      height: 16px;
      margin: 0;
    }
    .char-row:last-child { border-bottom: none; }
    .char-name {
      font-size: 13px;
      word-break: break-all;
    }
    .icon-thumb {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 1px solid #bfa98f;
      object-fit: cover;
      background: #fff;
    }
    .viewer-wrap {
      position: relative;
      min-height: calc(100vh - 32px);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .viewer-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      font-size: 13px;
    }
    .stage {
      flex: 0 0 auto;
      height: clamp(420px, 68vh, 760px);
      position: relative;
      border: 2px solid #d2bc9f;
      border-radius: 18px;
      background:
        linear-gradient(160deg, rgba(255,255,255,.72), rgba(255,249,237,.9)),
        repeating-linear-gradient(45deg, rgba(255,255,255,.25), rgba(255,255,255,.25) 10px, rgba(250,241,224,.25) 10px, rgba(250,241,224,.25) 20px);
      overflow-y: auto;
      overflow-x: hidden;
      cursor: pointer;
    }
    .stage-note {
      position: absolute;
      top: 10px;
      right: 12px;
      font-size: 12px;
      color: #6f5f4c;
      opacity: .8;
      pointer-events: none;
    }
    .log-flow {
      position: relative;
      min-height: 100%;
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 18px;
    }
    .entry {
      display: flex;
      gap: 10px;
      align-items: flex-end;
      width: 100%;
      animation: rise .14s ease;
    }
    .entry-avatar {
      width: 90px;
      height: 90px;
      border-radius: 50%;
      border: 3px solid #f4e3cc;
      object-fit: cover;
      background: #fff;
      flex-shrink: 0;
    }
    .bubble {
      max-width: min(720px, 90%);
      border-radius: 16px;
      border: 2px solid var(--line);
      background: #fff;
      padding: 12px 14px;
      position: relative;
      box-shadow: 0 8px 16px rgba(0,0,0,.08);
    }
    .meta {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 6px;
      font-size: 12px;
    }
    .tag {
      background: #f1e5d7;
      border: 1px solid #ddc9b2;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 11px;
    }
    .name {
      font-weight: 700;
      font-size: 13px;
    }
    .line {
      white-space: pre-wrap;
      line-height: 1.6;
      font-size: 18px;
      min-height: 2.5em;
    }
    .entry.narration {
      justify-content: center;
    }
    .entry.narration .entry-avatar {
      display: none;
    }
    .narration {
      margin: 0 auto;
      max-width: 860px;
      text-align: center;
      border-style: dashed;
      background: #fffefb;
    }
    @keyframes rise {
      from { opacity: .4; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .viewer-foot {
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    #fileInput { display: none; }
    .empty {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-size: 16px;
      color: #6d5f4e;
      text-align: center;
      padding: 20px;
    }
    @media (max-width: 960px) {
      .layout { grid-template-columns: 1fr; }
      .viewer-wrap { min-height: 60vh; }
      .stage { height: 58vh; }
      .entry-avatar { width: 74px; height: 74px; }
      .line { font-size: 16px; }
    }
  </style>
</head>
<body>
  <div class="layout">
    <aside class="panel">
      <h1>TRPGログ整形ツール</h1>
      <label class="file-label" for="fileInput">ログファイルを選択</label>
      <input id="fileInput" type="file" accept=".txt,.log,.html,.htm">
      <div id="fileName" class="hint">未選択</div>
      <div id="loadStatus" class="hint"></div>
      <div class="toolbar">
        <button id="exportBtn" class="primary" disabled>HTMLを出力</button>
      </div>

      <h2>属性フィルタ</h2>
      <div class="toolbar">
        <button id="allOnBtn" disabled>全選択</button>
        <button id="allOffBtn" disabled>全解除</button>
      </div>
      <div id="attributesBox" class="scroll"></div>

      <h2>キャラクター設定</h2>
      <div class="hint">色とアイコンは出力HTMLにも埋め込まれます。</div>
      <div id="charactersBox" class="char-list"></div>
    </aside>

    <main class="panel viewer-wrap">
      <div class="viewer-head">
        <div id="progress">0 / 0</div>
        <div class="hint">タップ・クリック・→で次へ / ←で戻る</div>
      </div>
      <section id="stage" class="stage" tabindex="0">
        <div class="stage-note">Next ▶</div>
        <div id="emptyState" class="empty">左の「ログファイルを選択」から読み込んでください。</div>
        <div id="logFlow" class="log-flow" hidden></div>
      </section>
      <div class="viewer-foot">
        <button id="prevBtn" disabled>◀ 戻る</button>
        <button id="nextBtn" disabled>次へ ▶</button>
      </div>
    </main>
  </div>

  <script>
    const fileInput = document.getElementById("fileInput");
    const fileName = document.getElementById("fileName");
    const loadStatus = document.getElementById("loadStatus");
    const attributesBox = document.getElementById("attributesBox");
    const charactersBox = document.getElementById("charactersBox");
    const exportBtn = document.getElementById("exportBtn");
    const allOnBtn = document.getElementById("allOnBtn");
    const allOffBtn = document.getElementById("allOffBtn");
    const stage = document.getElementById("stage");
    const emptyState = document.getElementById("emptyState");
    const logFlow = document.getElementById("logFlow");
    const progress = document.getElementById("progress");
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");

    const defaultAvatar =
      "data:image/svg+xml;base64," +
      btoa(unescape(encodeURIComponent(
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">' +
        '<rect width="64" height="64" fill="#f5e7d3"/>' +
        '<circle cx="32" cy="24" r="12" fill="#d4b896"/>' +
        '<rect x="16" y="40" width="32" height="16" rx="8" fill="#d4b896"/>' +
        "</svg>"
      )));

    let entries = [];
    let filteredEntries = [];
    let activeAttrs = new Set();
    let charMap = {};
    let cursor = 0;

    fileInput.addEventListener("change", async (event) => {
      const file = event.target.files?.[0];
      if (!file) return;
      try {
        const text = await readTextWithEncoding(file);
        fileName.textContent = file.name;
        bootFromLog(text, file.name);
      } catch (error) {
        loadStatus.textContent = `読込エラー: ${error?.message || error}`;
      }
    });

    allOnBtn.addEventListener("click", () => {
      const keys = Object.keys(getAttributeCounts());
      activeAttrs = new Set(keys);
      renderAttributeFilters();
      applyFiltersAndRender();
    });

    allOffBtn.addEventListener("click", () => {
      activeAttrs = new Set();
      renderAttributeFilters();
      applyFiltersAndRender();
    });

    prevBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      moveCursor(-1);
    });
    nextBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      moveCursor(1);
    });

    stage.addEventListener("click", () => moveCursor(1));

    document.addEventListener("keydown", (event) => {
      if (event.key === "ArrowRight") moveCursor(1);
      if (event.key === "ArrowLeft") moveCursor(-1);
    });

    exportBtn.addEventListener("click", () => {
      if (!entries.length) return;
      const payload = {
        entries,
        charMap,
        activeAttrs: Array.from(activeAttrs),
      };
      const html = buildExportHtml(payload);
      const blob = new Blob([html], { type: "text/html;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "trpg-comic-viewer.html";
      a.click();
      URL.revokeObjectURL(url);
    });

    function bootFromLog(text, fileName = "") {
      entries = parseAnyLog(text, fileName);
      charMap = buildCharacterMap(entries);
      const attrs = Object.keys(getAttributeCounts());
      activeAttrs = new Set(attrs);
      cursor = 0;
      renderAttributeFilters();
      renderCharacterSettings();
      applyFiltersAndRender();
      exportBtn.disabled = entries.length === 0;
      allOnBtn.disabled = attrs.length === 0;
      allOffBtn.disabled = attrs.length === 0;
      const chars = Object.keys(charMap).length;
      loadStatus.textContent = `読み込み: ${entries.length}件 / 属性:${attrs.length} / キャラ:${chars}`;
    }

    async function readTextWithEncoding(file) {
      const bytes = await file.arrayBuffer();
      const utf8 = new TextDecoder("utf-8", { fatal: false }).decode(bytes);
      // Shift_JIS exports are common in TRPG tools.
      if (looksMojibake(utf8)) {
        try {
          const sjis = new TextDecoder("shift_jis", { fatal: false }).decode(bytes);
          if (!looksMojibake(sjis)) return sjis;
        } catch (_) {
          // Ignore and keep UTF-8 fallback.
        }
      }
      return utf8;
    }

    function looksMojibake(text) {
      if (!text) return false;
      const replacement = (text.match(/\uFFFD/g) || []).length;
      return replacement >= 2;
    }

    function parseAnyLog(raw, fileName = "") {
      const isHtmlFile = /\.(html?|xhtml)$/i.test(fileName);
      const looksHtml = /<html[\s>]|<body[\s>]|<p[\s>]|<\/p>/i.test(raw);
      if (isHtmlFile || looksHtml) {
        const htmlEntries = parseHtmlLog(raw);
        if (htmlEntries.length) return htmlEntries;
        const stripped = raw
          .replace(/<br\s*\/?>/gi, "\n")
          .replace(/<\/p>/gi, "\n")
          .replace(/<[^>]+>/g, "");
        const textFallback = parseLog(stripped);
        if (textFallback.length) return textFallback;
      }
      return parseLog(raw);
    }

    function parseHtmlLog(raw) {
      const doc = new DOMParser().parseFromString(raw, "text/html");
      const pNodes = Array.from(doc.querySelectorAll("p"));
      const out = [];

      const normalizeAttr = (s) => {
        const cleaned = (s || "").replace(/[\[\]]/g, "").trim();
        return cleaned || "NO_ATTR";
      };
      const normalizeSpeaker = (s) => normalizeSpeakerName(s);

      for (const p of pNodes) {
        const sourceColor = parseCssColorFromStyle(p.getAttribute("style") || "");
        const spans = Array.from(p.querySelectorAll("span"))
          .map((span) => span.textContent?.trim() || "")
          .filter(Boolean);

        let attr = "";
        let speaker = "";
        let text = "";

        if (spans.length >= 3) {
          attr = normalizeAttr(spans[0]);
          speaker = normalizeSpeaker(spans[1]);
          text = spans.slice(2).join("\n").trim();
        } else {
          const plain = (p.textContent || "").trim().replace(/\s+/g, " ");
          const m = plain.match(/^\[([^\]]+)\]\s*(.+?)\s*[:：]\s*(.*)$/);
          if (m) {
            attr = normalizeAttr(m[1]);
            speaker = normalizeSpeaker(m[2]);
            text = (m[3] || "").trim();
          } else if (plain) {
            const attrOnly = plain.match(/^\[([^\]]+)\]\s*(.*)$/);
            if (attrOnly) {
              attr = normalizeAttr(attrOnly[1]);
              text = (attrOnly[2] || "").trim();
            } else {
              attr = "NO_ATTR";
              text = plain;
            }
          }
        }

        if (!text) continue;
        out.push({
          attr: attr || "NO_ATTR",
          speaker: speaker || "",
          text,
          kind: speaker ? "speech" : "narration",
          ...(sourceColor ? { sourceColor } : {}),
        });
      }

      if (!out.length) {
        // Fallback for malformed HTML exports.
        const chunks = raw.match(/<p[\s\S]*?<\/p>/gi) || [];
        for (const chunk of chunks) {
          const spanTexts = [];
          const re = /<span[^>]*>([\s\S]*?)<\/span>/gi;
          let m;
          while ((m = re.exec(chunk)) !== null) {
            const decoded = decodeHtmlEntities(m[1]).trim();
            if (decoded) spanTexts.push(decoded);
          }
          const styleMatch = chunk.match(/style\s*=\s*["']([^"']*)["']/i);
          const sourceColor = parseCssColorFromStyle(styleMatch?.[1] || "");
          if (spanTexts.length >= 3) {
            const attr = normalizeAttr(spanTexts[0]);
            const speaker = normalizeSpeaker(spanTexts[1]);
            const text = spanTexts.slice(2).join("\n").trim();
            if (text) {
              out.push({
                attr: attr || "NO_ATTR",
                speaker: speaker || "",
                text,
                kind: speaker ? "speech" : "narration",
                ...(sourceColor ? { sourceColor } : {}),
              });
            }
          }
        }
      }

      return out;
    }

    function decodeHtmlEntities(input) {
      const el = document.createElement("textarea");
      el.innerHTML = input;
      return el.value;
    }

    function normalizeSpeakerName(input) {
      const base = String(input || "");
      return base
        .normalize("NFKC")
        .replace(/[:：]\s*$/, "")
        .replace(/\s+/g, " ")
        .trim();
    }

    function parseCssColorFromStyle(styleText) {
      if (!styleText) return "";
      const m = styleText.match(/(?:^|;)\s*color\s*:\s*([^;]+)/i);
      if (!m) return "";
      const candidate = m[1].trim();
      const test = document.createElement("span");
      test.style.color = "";
      test.style.color = candidate;
      return test.style.color ? candidate : "";
    }

    function parseLog(raw) {
      const lines = raw.replace(/\r\n/g, "\n").split("\n");
      const out = [];
      const speechHeader = /^\[([^\]]+)\]\s*(.+?)\s*:\s*(.*)$/;
      const attrOnly = /^\[([^\]]+)\]\s*(.*)$/;
      let current = null;

      const pushCurrent = () => {
        if (!current) return;
        current.text = current.lines.join("\n").trimEnd();
        delete current.lines;
        out.push(current);
        current = null;
      };

      for (const line of lines) {
        const match = line.match(speechHeader);
        if (match) {
          pushCurrent();
          current = {
            attr: match[1].trim(),
            speaker: normalizeSpeakerName(match[2]),
            lines: [match[3] ?? ""],
            kind: "speech",
          };
          continue;
        }
        const attrMatch = line.match(attrOnly);
        if (attrMatch) {
          pushCurrent();
          current = {
            attr: attrMatch[1].trim(),
            speaker: "",
            lines: [attrMatch[2] ?? ""],
            kind: "narration",
          };
          continue;
        }
        if (current) {
          current.lines.push(line);
        } else if (line.trim() !== "") {
          out.push({
            attr: "NO_ATTR",
            speaker: "",
            text: line,
            kind: "narration",
          });
        }
      }
      pushCurrent();

      return out.filter((item) => item.text !== "");
    }

    function buildCharacterMap(list) {
      const map = {};
      const colorCountsBySpeaker = {};

      list.forEach((item) => {
        if (!item.speaker || !item.sourceColor) return;
        colorCountsBySpeaker[item.speaker] ||= {};
        colorCountsBySpeaker[item.speaker][item.sourceColor] =
          (colorCountsBySpeaker[item.speaker][item.sourceColor] || 0) + 1;
      });

      const names = [...new Set(
        list
          .filter((item) => item.speaker)
          .map((item) => item.speaker)
      )];
      names.forEach((name, index) => {
        const bucket = colorCountsBySpeaker[name] || {};
        const picked = Object.keys(bucket).sort((a, b) => bucket[b] - bucket[a])[0];
        map[name] = {
          color: picked || autoColor(index),
          icon: defaultAvatar,
          visible: true,
        };
      });
      return map;
    }

    function autoColor(index) {
      const hue = (index * 67 + 32) % 360;
      return `hsl(${hue} 74% 80%)`;
    }

    function getAttributeCounts() {
      const counts = {};
      entries.forEach((item) => {
        counts[item.attr] = (counts[item.attr] || 0) + 1;
      });
      return counts;
    }

    function renderAttributeFilters() {
      const counts = getAttributeCounts();
      attributesBox.innerHTML = "";
      const attrs = Object.keys(counts);
      if (!attrs.length) {
        attributesBox.textContent = "属性はまだありません。";
        return;
      }
      attrs.forEach((attr) => {
        const row = document.createElement("label");
        row.className = "attr-item";
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = activeAttrs.has(attr);
        checkbox.addEventListener("change", () => {
          if (checkbox.checked) activeAttrs.add(attr);
          else activeAttrs.delete(attr);
          applyFiltersAndRender();
        });
        const text = document.createElement("span");
        const attrText = attr === "NO_ATTR" ? "(属性なし)" : attr;
        text.textContent = `${attrText} (${counts[attr]})`;
        row.append(checkbox, text);
        attributesBox.appendChild(row);
      });
    }

    function renderCharacterSettings() {
      charactersBox.innerHTML = "";
      const names = Object.keys(charMap);
      if (!names.length) {
        charactersBox.textContent = "キャラクターが見つかりません。";
        return;
      }
      names.forEach((name) => {
        const row = document.createElement("div");
        row.className = "char-row";

        const visible = document.createElement("input");
        visible.type = "checkbox";
        visible.className = "char-toggle";
        visible.title = "表示/非表示";
        visible.checked = charMap[name].visible !== false;
        visible.addEventListener("change", () => {
          charMap[name].visible = visible.checked;
          applyFiltersAndRender();
        });

        const nameEl = document.createElement("div");
        nameEl.className = "char-name";
        nameEl.textContent = name;

        const color = document.createElement("input");
        color.type = "color";
        color.value = toHex(charMap[name].color);
        color.title = "吹き出し色";
        color.addEventListener("input", () => {
          charMap[name].color = color.value;
          renderCurrent();
        });

        const thumb = document.createElement("img");
        thumb.className = "icon-thumb";
        thumb.src = charMap[name].icon || defaultAvatar;
        thumb.alt = `${name} icon`;

        const file = document.createElement("input");
        file.type = "file";
        file.accept = "image/*";
        file.title = "アイコン画像";
        file.addEventListener("change", async () => {
          const selected = file.files?.[0];
          if (!selected) return;
          charMap[name].icon = await readAsDataUrl(selected);
          thumb.src = charMap[name].icon;
          renderCurrent();
        });

        row.append(visible, nameEl, color, thumb, file);
        charactersBox.appendChild(row);
      });
    }

    function toHex(color) {
      if (color.startsWith("#")) return color;
      const temp = document.createElement("div");
      temp.style.color = color;
      document.body.appendChild(temp);
      const rgb = getComputedStyle(temp).color;
      temp.remove();
      const nums = rgb.match(/\d+/g)?.map(Number) || [255, 255, 255];
      return "#" + nums.slice(0, 3).map((n) => n.toString(16).padStart(2, "0")).join("");
    }

    function readAsDataUrl(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(String(reader.result || ""));
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(file);
      });
    }

    function applyFiltersAndRender() {
      filteredEntries = entries.filter((item) => {
        if (!activeAttrs.has(item.attr)) return false;
        return isSpeakerVisible(item);
      });
      if (cursor >= filteredEntries.length) cursor = Math.max(0, filteredEntries.length - 1);
      renderCurrent();
    }

    function isSpeakerVisible(item) {
      if (!item.speaker) return true;
      const cfg = charMap[item.speaker];
      if (!cfg) return true;
      return cfg.visible !== false;
    }

    function moveCursor(delta) {
      if (!filteredEntries.length) return;
      const next = cursor + delta;
      if (next < 0 || next >= filteredEntries.length) return;
      cursor = next;
      renderCurrent();
    }

    function renderCurrent() {
      const total = filteredEntries.length;
      progress.textContent = total ? `${cursor + 1} / ${total}` : `0 / 0`;
      prevBtn.disabled = total === 0 || cursor === 0;
      nextBtn.disabled = total === 0 || cursor >= total - 1;

      if (!total) {
        logFlow.hidden = true;
        logFlow.innerHTML = "";
        emptyState.hidden = false;
        emptyState.textContent = entries.length
          ? "No visible entries. Change attribute filters on the left."
          : "Select a log file from the left panel.";
        return;
      }

      logFlow.hidden = false;
      emptyState.hidden = true;
      logFlow.innerHTML = "";

      const visible = filteredEntries.slice(0, cursor + 1);
      for (const item of visible) {
        logFlow.appendChild(createEntryNode(item));
      }
      stage.scrollTop = stage.scrollHeight;
    }

    function createEntryNode(item) {
      const entry = document.createElement("div");
      entry.className = "entry";

      const avatarEl = document.createElement("img");
      avatarEl.className = "entry-avatar";
      avatarEl.alt = "";

      const bubbleEl = document.createElement("article");
      bubbleEl.className = "bubble";
      const meta = document.createElement("div");
      meta.className = "meta";
      const attr = document.createElement("span");
      attr.className = "tag";
      attr.textContent = item.attr === "NO_ATTR" ? "(No Attr)" : item.attr;
      const name = document.createElement("span");
      name.className = "name";
      const line = document.createElement("div");
      line.className = "line";
      line.textContent = item.text;
      meta.append(attr, name);
      bubbleEl.append(meta, line);

      if (item.kind === "narration" || !item.speaker) {
        entry.classList.add("narration");
        name.textContent = "Narration";
        avatarEl.src = defaultAvatar;
        bubbleEl.classList.add("narration");
        bubbleEl.style.background = "#fffefb";
        bubbleEl.style.borderColor = "#d8c8b4";
        bubbleEl.style.color = "#4f4437";
      } else {
        const cfg = charMap[item.speaker] || { color: "#fff", icon: defaultAvatar };
        name.textContent = item.speaker;
        avatarEl.src = cfg.icon || defaultAvatar;
        bubbleEl.style.background = cfg.color || "#fff";
        bubbleEl.style.borderColor = shadeColor(cfg.color || "#ffffff", -30);
        bubbleEl.style.color = "#231f1b";
      }

      entry.append(avatarEl, bubbleEl);
      return entry;
    }
    function shadeColor(color, offset) {
      const hex = toHex(color);
      const num = parseInt(hex.slice(1), 16);
      const r = Math.max(0, Math.min(255, ((num >> 16) & 255) + offset));
      const g = Math.max(0, Math.min(255, ((num >> 8) & 255) + offset));
      const b = Math.max(0, Math.min(255, (num & 255) + offset));
      return "#" + [r, g, b].map((n) => n.toString(16).padStart(2, "0")).join("");
    }

    function buildExportHtml(payload) {
      const data = JSON.stringify(payload).replace(/</g, "\\u003c");
      return `<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>TRPG Comic Viewer</title>
  <style>
    body{margin:0;font-family:"Hiragino Kaku Gothic ProN","Yu Gothic UI","Meiryo",sans-serif;background:linear-gradient(145deg,#f7f1dc,#f9d8b6);color:#2f2a22}
    .root{max-width:1200px;margin:0 auto;padding:16px;display:grid;grid-template-columns:320px 1fr;gap:14px}
    .panel{background:#fffaf0;border:1px solid #cdb79f;border-radius:14px;padding:12px}
    .title{font-weight:700;margin-bottom:8px}
    .toolbar{display:flex;gap:6px;flex-wrap:wrap;margin-bottom:8px}
    button{border:1px solid #b79f85;background:#fff;border-radius:10px;padding:7px 10px;cursor:pointer}
    .box{max-height:220px;overflow:auto;border:1px solid #cdb79f;border-radius:8px;padding:6px;background:#fffcf7}
    .row{font-size:13px;margin:4px 0;display:flex;align-items:center;gap:6px}
    .char-row{display:grid;grid-template-columns:auto 1fr auto auto auto;align-items:center;gap:8px;padding:4px 0;border-bottom:1px dashed #d9c8b5}
    .char-row:last-child{border-bottom:none}
    .char-name{font-size:13px;word-break:break-all}
    .icon-thumb{width:26px;height:26px;border-radius:50%;border:1px solid #bfa98f;object-fit:cover;background:#fff}
    .head{display:flex;justify-content:space-between;align-items:center;font-size:13px;margin-bottom:10px}
    .flow{display:flex;flex-direction:column;gap:10px}
    .entry{display:flex;gap:10px;align-items:flex-end}
    .entry-avatar{width:76px;height:76px;border-radius:50%;border:3px solid #f4e3cc;object-fit:cover;background:#fff;flex-shrink:0}
    .bubble{max-width:min(760px,92%);border-radius:16px;border:2px solid #cdb79f;background:#fff;padding:12px 14px}
    .meta{display:flex;gap:8px;align-items:center;margin-bottom:6px;font-size:12px}
    .tag{background:#f1e5d7;border:1px solid #ddc9b2;border-radius:999px;padding:2px 8px;font-size:11px}
    .line{white-space:pre-wrap;line-height:1.6;font-size:17px}
    .entry.narration{justify-content:center}
    .entry.narration .entry-avatar{display:none}
    .entry.narration .bubble{margin:0 auto;max-width:900px;text-align:center;border-style:dashed;background:#fffefb;border-color:#d8c8b4;color:#4f4437}
    @media (max-width:920px){.root{grid-template-columns:1fr}.line{font-size:16px}.entry-avatar{width:66px;height:66px}}
  </style>
</head>
<body>
  <div class="root">
    <aside class="panel">
      <div class="title">属性フィルタ</div>
      <div class="toolbar"><button id="attrOn">全選択</button><button id="attrOff">全解除</button></div>
      <div id="attrs" class="box"></div>
      <div class="title" style="margin-top:12px">キャラ設定</div>
      <div id="chars" class="box"></div>
    </aside>
    <main class="panel">
      <div class="head"><div style="font-weight:700">対話ログ</div><div id="progress">0件</div></div>
      <section id="flow" class="flow"></section>
    </main>
  </div>
  <script>
    const payload = ${data};
    const defaultAvatar = "${defaultAvatar}";
    const entries = payload.entries || [];
    const charMap = JSON.parse(JSON.stringify(payload.charMap || {}));
    const flow = document.getElementById("flow");
    const progress = document.getElementById("progress");
    const attrsBox = document.getElementById("attrs");
    const charsBox = document.getElementById("chars");
    let activeAttrs = new Set(payload.activeAttrs || []);
    function hex(c){if((c||"").startsWith("#")) return c; const d=document.createElement("div"); d.style.color=c||"#fff"; document.body.appendChild(d); const rgb=getComputedStyle(d).color; d.remove(); const n=rgb.match(/\\d+/g).map(Number); return "#" + n.slice(0,3).map(v=>v.toString(16).padStart(2,"0")).join("");}
    function shade(c,o){const h=hex(c),n=parseInt(h.slice(1),16),r=Math.max(0,Math.min(255,((n>>16)&255)+o)),g=Math.max(0,Math.min(255,((n>>8)&255)+o)),b=Math.max(0,Math.min(255,(n&255)+o));return "#" + [r,g,b].map(v=>v.toString(16).padStart(2,"0")).join("")}
    function getCounts(){const m={}; entries.forEach(e=>m[e.attr]=(m[e.attr]||0)+1); return m;}
    function readAsDataUrl(file){return new Promise((resolve,reject)=>{const r=new FileReader(); r.onload=()=>resolve(String(r.result||"")); r.onerror=()=>reject(r.error); r.readAsDataURL(file);});}
    function speakerVisible(e){if(!e.speaker) return true; const cfg=charMap[e.speaker]; if(!cfg) return true; return cfg.visible !== false;}
    function nodeFor(it){const e=document.createElement("div"); e.className="entry"; const img=document.createElement("img"); img.className="entry-avatar"; img.alt=""; const b=document.createElement("article"); b.className="bubble"; const m=document.createElement("div"); m.className="meta"; const t=document.createElement("span"); t.className="tag"; t.textContent=(it.attr==="NO_ATTR")?"(属性なし)":it.attr; const n=document.createElement("span"); n.className="name"; const l=document.createElement("div"); l.className="line"; l.textContent=it.text; m.append(t,n); b.append(m,l);
      if(it.kind==="narration"||!it.speaker){e.classList.add("narration"); n.textContent="地の文"; img.src=defaultAvatar;}
      else {const cfg=charMap[it.speaker]||{}; n.textContent=it.speaker; img.src=cfg.icon||defaultAvatar; b.style.background=cfg.color||"#fff"; b.style.borderColor=shade(cfg.color||"#fff",-30);}
      e.append(img,b); return e;}
    function renderAttrs(){attrsBox.innerHTML=""; const c=getCounts(); const keys=Object.keys(c); if(!keys.length){attrsBox.textContent="属性なし"; return;} keys.forEach(a=>{const row=document.createElement("label"); row.className="row"; const ck=document.createElement("input"); ck.type="checkbox"; ck.checked=activeAttrs.has(a); ck.onchange=()=>{ck.checked?activeAttrs.add(a):activeAttrs.delete(a); renderAll();}; const text=document.createElement("span"); text.textContent=((a==="NO_ATTR")?"(属性なし)":a)+" ("+c[a]+")"; row.append(ck,text); attrsBox.append(row);});}
    function renderChars(){charsBox.innerHTML=""; const names=Object.keys(charMap); if(!names.length){charsBox.textContent="キャラなし"; return;} names.forEach(name=>{const cfg=charMap[name]||{}; const row=document.createElement("div"); row.className="char-row";
      const vis=document.createElement("input"); vis.type="checkbox"; vis.checked=cfg.visible!==false; vis.onchange=()=>{cfg.visible=vis.checked; renderAll();};
      const nameEl=document.createElement("div"); nameEl.className="char-name"; nameEl.textContent=name;
      const color=document.createElement("input"); color.type="color"; color.value=hex(cfg.color||"#ffffff"); color.oninput=()=>{cfg.color=color.value; renderAll();};
      const thumb=document.createElement("img"); thumb.className="icon-thumb"; thumb.src=cfg.icon||defaultAvatar; thumb.alt=name;
      const file=document.createElement("input"); file.type="file"; file.accept="image/*"; file.onchange=async()=>{const f=file.files&&file.files[0]; if(!f) return; cfg.icon=await readAsDataUrl(f); thumb.src=cfg.icon; renderAll();};
      row.append(vis,nameEl,color,thumb,file); charsBox.append(row);});}
    function renderAll(){const visible=entries.filter(e=>activeAttrs.has(e.attr)&&speakerVisible(e)); progress.textContent=visible.length+"件"; flow.innerHTML=""; if(!visible.length){const note=document.createElement("div"); note.className="line"; note.textContent="表示対象がありません"; flow.append(note); return;} visible.forEach(it=>flow.appendChild(nodeFor(it)));}
    document.getElementById("attrOn").onclick=()=>{activeAttrs=new Set(Object.keys(getCounts())); renderAttrs(); renderAll();};
    document.getElementById("attrOff").onclick=()=>{activeAttrs=new Set(); renderAttrs(); renderAll();};
    renderAttrs(); renderChars(); renderAll();
  <\/script>
</body>
</html>`;
    }
  </script>
</body>
</html>
